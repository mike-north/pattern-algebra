## API Report File for "@pattern-algebra/core"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// @public
export interface Alternation {
    // (undocumented)
    readonly branches: readonly PatternNode[];
    // (undocumented)
    readonly type: 'alternation';
}

// @public
export function analyzePatterns(a: CompiledPattern, b: CompiledPattern): PatternAnalysis;

// @public
export interface AnchoringComparison {
    readonly differ: boolean;
    readonly explanation?: string;
    readonly patternAAbsolute: boolean;
    readonly patternBAbsolute: boolean;
}

// @public
export function applyQuickReject(path: string, filter: QuickRejectFilter): boolean;

// @public
export function areDisjoint(a: CompiledPattern, b: CompiledPattern): boolean;

// @public
export function areEquivalent(a: CompiledPattern, b: CompiledPattern): boolean;

// @public
export class AutomatonLimitError extends Error {
    constructor(code: PatternErrorCode, message: string, limit: number, actual: number);
    readonly actual: number;
    readonly code: PatternErrorCode;
    readonly limit: number;
}

// @public
export interface AutomatonState {
    readonly accepting: boolean;
    readonly id: number;
    readonly transitions: readonly AutomatonTransition[];
}

// @public
export type AutomatonTransition = LiteralTransition | WildcardTransition | GlobstarTransition | EpsilonTransition;

// @public
export function buildAutomaton(pattern: PathPattern): SegmentAutomaton;

// @public
export function buildQuickRejectFilter(pattern: PathPattern): QuickRejectFilter;

// @public
export interface CharClassSegment {
    readonly chars: string;
    readonly negated: boolean;
    readonly ranges: readonly CharRange[];
    // (undocumented)
    readonly type: 'charclass';
}

// @public
export interface CharRange {
    readonly end: string;
    readonly start: string;
}

// @public
export function checkContainment(a: CompiledPattern, b: CompiledPattern): ContainmentResult;

// @public
export function commonPrefix(pathA: string, pathB: string): string;

// @public
export interface CompiledPattern {
    readonly ast: PathPattern;
    readonly automaton: SegmentAutomaton;
    readonly isUnbounded: boolean;
    readonly maxSegments?: number;
    readonly minSegments: number;
    readonly quickReject: QuickRejectFilter;
    readonly source: string;
}

// @public
export function compilePattern(pattern: PathPattern): CompiledPattern;

// @public
export function complement(automaton: SegmentAutomaton): SegmentAutomaton;

// @public
export interface CompositeSegment {
    // (undocumented)
    readonly parts: readonly SegmentPart[];
    // (undocumented)
    readonly type: 'composite';
}

// @public
export interface ContainmentExplanation {
    readonly failureReasons: readonly ContainmentFailureReason[];
    readonly segmentComparison: readonly SegmentComparisonEntry[];
    readonly structuralDiffs: StructuralDifferences;
    readonly witnesses: readonly WitnessPath[];
}

// @public
export type ContainmentFailureReason = 'depth_mismatch' | 'prefix_mismatch' | 'suffix_mismatch' | 'segment_mismatch' | 'charclass_mismatch' | 'negation_conflict' | 'alternation_escape';

// @public
export interface ContainmentResult {
    readonly counterexample?: string;
    readonly explanation: ContainmentExplanation;
    readonly hasOverlap: boolean;
    readonly isEqual: boolean;
    readonly isSubset: boolean;
    readonly isSuperset: boolean;
    readonly patternA: string;
    readonly patternB: string;
    readonly relationship: PatternRelationship;
    readonly reverseCounterexample?: string;
}

// @public
export function countBraceExpansions(source: string): number;

// @public
export function countPaths(automaton: SegmentAutomaton, maxDepth: number): Map<number, number>;

// @public
export const DEFAULT_MAX_DFA_STATES = 10000;

// @public
export interface DepthComparison {
    readonly differ: boolean;
    readonly explanation?: string;
    readonly patternAMax: number | 'unbounded';
    readonly patternAMin: number;
    readonly patternBMax: number | 'unbounded';
    readonly patternBMin: number;
}

// @public
export function determinize(nfa: SegmentAutomaton, options?: DeterminizeOptions): SegmentAutomaton;

// @public
export interface DeterminizeOptions {
    maxStates?: number;
}

// @public
export interface EpsilonTransition {
    // (undocumented)
    readonly target: number;
    // (undocumented)
    readonly type: 'epsilon';
}

// @public
export function expandBraces(pattern: PathPattern, maxExpansion?: number): readonly PathPattern[];

// @public
export function findWitness(automaton: SegmentAutomaton): string | undefined;

// @public
export function getBasename(path: string): string;

// @public
export function getDirname(path: string): string;

// @public
export function getExtension(pathOrSegment: string): string;

// @public
export function getMaxSegments(pattern: PathPattern): number | undefined;

// @public
export function getMinSegments(pattern: PathPattern): number;

// @public
export interface GlobstarSegment {
    // (undocumented)
    readonly type: 'globstar';
}

// @public
export interface GlobstarTransition {
    readonly exit: number;
    readonly selfLoop: number;
    // (undocumented)
    readonly type: 'globstar';
}

// @public
export function hasOverlap(a: CompiledPattern, b: CompiledPattern): boolean;

// @public
export function intersect(a: SegmentAutomaton, b: SegmentAutomaton): SegmentAutomaton;

// @public
export function isAbsolutePath(path: string): boolean;

// @public
export function isAncestorPath(ancestor: string, descendant: string): boolean;

// @public
export function isEmpty(automaton: SegmentAutomaton): boolean;

// @public
export function isUnbounded(pattern: PathPattern): boolean;

// @public
export function isValidPattern(pattern: PathPattern): boolean;

// @public
export interface LiteralSegment {
    // (undocumented)
    readonly type: 'literal';
    // (undocumented)
    readonly value: string;
}

// @public
export interface LiteralTransition {
    // (undocumented)
    readonly segment: string;
    readonly target: number;
    // (undocumented)
    readonly type: 'literal';
}

// @public
export function matchPath(path: string, pattern: CompiledPattern): boolean;

// @public
export function matchPathDirect(path: string, pattern: PathPattern): boolean;

// @public
export function matchPathWithContext(path: string, pattern: CompiledPattern, context: PathContext): boolean;

// @public
export function matchSegment(segment: string, pattern: Segment): boolean;

// @public
export function normalizePath(path: string, context: PathContext): string;

// @public
export function parsePattern(source: string): PathPattern;

// @public
export interface PathContext {
    readonly cwd: string;
    readonly homeDir: string;
    readonly projectRoot?: string;
}

// @public
export interface PathPattern {
    readonly errors?: readonly PatternError[];
    readonly isAbsolute: boolean;
    readonly isNegation: boolean;
    readonly root: PatternNode;
    readonly source: string;
}

// @public
export function pathToSegments(path: string): readonly string[];

// @public
export interface PatternAnalysis {
    readonly aMinusB: PatternDescription;
    readonly bMinusA: PatternDescription;
    readonly containment: ContainmentResult;
    readonly intersection: PatternDescription;
    // (undocumented)
    readonly patternA: string;
    // (undocumented)
    readonly patternB: string;
    // (undocumented)
    readonly relationship: PatternRelationship;
}

// @public
export function patternComplement(a: CompiledPattern): CompiledPattern;

// @public
export interface PatternDescription {
    readonly description: string;
    readonly examples?: readonly string[];
    readonly isEmpty: boolean;
    readonly pattern?: string;
}

// @public
export function patternDifference(a: CompiledPattern, b: CompiledPattern): CompiledPattern;

// @public
export interface PatternError {
    readonly code: PatternErrorCode;
    readonly length?: number;
    readonly message: string;
    readonly position?: number;
}

// @public
export type PatternErrorCode = 'INVALID_GLOBSTAR' | 'UNCLOSED_BRACKET' | 'UNCLOSED_BRACE' | 'EMPTY_CHARCLASS' | 'INVALID_RANGE' | 'EXPANSION_LIMIT' | 'NESTED_BRACES' | 'INVALID_ESCAPE' | 'BANNED_FEATURE' | 'INVALID_REGEX' | 'UNSAFE_REGEX' | 'DFA_STATE_LIMIT';

// @public
export function patternIntersect(a: CompiledPattern, b: CompiledPattern): CompiledPattern;

// @public
export type PatternNode = SegmentSequence | Alternation;

// @public
export type PatternRelationship = 'subset' | 'equal' | 'superset' | 'overlapping' | 'disjoint';

// @public
export function patternUnion(a: CompiledPattern, b: CompiledPattern): CompiledPattern;

// @public
export interface PrefixComparison {
    readonly differ: boolean;
    readonly explanation?: string;
    readonly patternAPrefix?: string;
    readonly patternBPrefix?: string;
}

// @public
export interface QuickRejectFilter {
    readonly minLength?: number;
    readonly requiredLiterals?: readonly string[];
    readonly requiredPrefix?: string;
    readonly requiredSuffix?: string;
}

// @public
export type Segment = LiteralSegment | WildcardSegment | GlobstarSegment | CharClassSegment | CompositeSegment;

// @public
export interface SegmentAutomaton {
    readonly acceptingStates: readonly number[];
    readonly initialState: number;
    readonly isDeterministic: boolean;
    readonly states: readonly AutomatonState[];
}

// @public
export interface SegmentComparisonEntry {
    readonly aSubsetOfB: boolean;
    readonly difference?: string;
    readonly patternAAllows: SegmentConstraint;
    readonly patternBAllows: SegmentConstraint;
    readonly position: number;
}

// @public
export interface SegmentConstraint {
    readonly charclassDescription?: string;
    readonly literalValue?: string;
    readonly optional: boolean;
    readonly repeatable: boolean;
    readonly type: SegmentConstraintType;
    readonly wildcardPattern?: string;
}

// @public
export type SegmentConstraintType = 'literal' | 'wildcard' | 'charclass' | 'any' | 'any_sequence' | 'end' | 'unreachable';

// @public
export type SegmentPart = {
    readonly type: 'literal';
    readonly value: string;
} | {
    readonly type: 'star';
} | {
    readonly type: 'question';
} | {
    readonly type: 'charclass';
    readonly spec: CharClassSegment;
};

// @public
export interface SegmentSequence {
    // (undocumented)
    readonly segments: readonly Segment[];
    // (undocumented)
    readonly type: 'sequence';
}

// @public
export function segmentsToPath(segments: readonly string[]): string;

// @public
export function segmentToRegex(pattern: Segment): RegExp | null;

// @public
export interface StructuralDifferences {
    readonly anchoringDifference: AnchoringComparison;
    readonly depthDifference: DepthComparison;
    readonly prefixDifference: PrefixComparison;
    readonly suffixDifference: SuffixComparison;
}

// @public
export interface SuffixComparison {
    readonly differ: boolean;
    readonly explanation?: string;
    readonly patternASuffix?: string;
    readonly patternBSuffix?: string;
}

// @public
export function summarizeRelationship(relationship: PatternRelationship, patternA: string, patternB: string): string;

// @public
export function union(a: SegmentAutomaton, b: SegmentAutomaton): SegmentAutomaton;

// @public
export function validatePattern(pattern: PathPattern): readonly PatternError[];

// @public
export const version = "0.0.0";

// @public
export type WildcardPart = {
    readonly type: 'literal';
    readonly value: string;
} | {
    readonly type: 'star';
} | {
    readonly type: 'question';
};

// @public
export interface WildcardSegment {
    readonly parts: readonly WildcardPart[];
    readonly pattern: string;
    // (undocumented)
    readonly type: 'wildcard';
}

// @public
export interface WildcardTransition {
    // Warning: (ae-forgotten-export) The symbol "SegmentMatcher" needs to be exported by the entry point index.d.ts
    readonly pattern: RegExp | SegmentMatcher;
    readonly patternSource: string;
    // (undocumented)
    readonly target: number;
    // (undocumented)
    readonly type: 'wildcard';
}

// @public
export type WitnessCategory = 'counterexample' | 'reverse_counterexample' | 'shared' | 'neither';

// @public
export interface WitnessPath {
    readonly category: WitnessCategory;
    readonly divergenceIndex?: number;
    readonly matchesA: boolean;
    // (undocumented)
    readonly matchesB: boolean;
    readonly path: string;
}

```
